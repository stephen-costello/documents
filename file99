# Fidelity QE Automation Standards - AI Assistant Guide

## Quick Reference for AI Assistants

### MANDATORY DEFAULTS
- **Primary Language**: TypeScript
- **Primary Framework**: Playwright
- **Secondary Frameworks**: Karate (API), Selenium (legacy)
- **Test File Naming**: `*.spec.ts` (Playwright), `*.feature` (Karate)
- **Design Pattern**: Page Object Model (ALWAYS)
- **Wait Strategy**: Explicit waits ONLY (NEVER implicit waits)
- **Authentication**: ALWAYS fetch from Vault (NEVER hardcode)
- **Case Styles**: 
  - Classes: PascalCase
  - Methods/Variables: camelCase
  - Files: kebab-case
  - Test Names: Descriptive with action verbs

### CRITICAL RULES
```
‚úÖ ALWAYS DO:
- Use Page Object Model pattern
- Fetch secrets from Vault
- Include at least one test tag (@Smoke, @Functional, @Regression, @E2E, @Health)
- Add comprehensive error handling with try-catch
- Capture screenshots on failure
- Log all critical actions
- Include meaningful assertions with descriptive messages
- Follow camelCase for methods and variables

‚ùå NEVER DO:
- Hardcode credentials, API keys, or PII
- Use implicit waits (Selenium/Playwright)
- Create tests without tags
- Skip error handling
- Leave commented-out code in production
- Use sleep() or fixed waits
- Duplicate code (use utility functions)
- Skip documentation for complex logic
```

---

## 1. Fidelity-Specific Context

### Our Technology Stack
- **Frontend**: Angular (FocusPoint desktop application)
- **API Testing**: Karate, Bruno
- **UI Testing**: Playwright (primary), Selenium (legacy migration)
- **Secret Management**: HashiCorp Vault
- **Observability**: Grafana, Datadog, Report Portal
- **Test Management**: Jira/Xray
- **CI/CD**: [Add your pipeline tool]
- **Browser**: Chrome (migrated from OpenFin)

### Business Domain
- **US Retirement Market**: 401(k) processing, loans, withdrawals
- **Compliance**: Fintech regulations, PII handling, audit trails
- **Users**: Internal operations teams, financial advisors, plan participants

### 8-Layer Testing Strategy
Our comprehensive testing approach covers:
1. **Synthetic Monitoring** - Production health checks
2. **E2E Testing** - Complete user journeys
3. **Integration Testing** - Service-to-service validation
4. **API Testing** - Contract and functional validation
5. **Unit Testing** - Component-level validation
6. **Performance Testing** - Load and stress testing
7. **Security Testing** - Vulnerability scanning
8. **Observability** - Real-time monitoring and alerting

### Quality Metrics & Dashboards
- **Weighted Quality Score**: Calculated from Report Portal, Grafana, Datadog, Jira/Xray
- **Test Execution KPIs**: 
  - Pass rate target: >95%
  - Test execution time: <30 min for smoke, <2 hours for regression
  - Flakiness rate: <2%
- **Dashboard Requirements**: Real-time monitoring with unified metrics

---

## 2. AI Assistant Decision Trees

### When User Requests Test Creation

```
IF request contains "test" OR "automate" OR "validate":
  ‚îú‚îÄ Ask: What type of test? (UI, API, E2E, Performance)
  ‚îú‚îÄ IF UI test:
  ‚îÇ   ‚îú‚îÄ Use Playwright with Page Object Model
  ‚îÇ   ‚îú‚îÄ Ask for: page/component, user flow, expected outcomes
  ‚îÇ   ‚îú‚îÄ Generate: Page object class + spec file + utility functions
  ‚îÇ   ‚îî‚îÄ Include: Error handling, screenshots, logging, tags
  ‚îú‚îÄ IF API test:
  ‚îÇ   ‚îú‚îÄ Use Karate framework
  ‚îÇ   ‚îú‚îÄ Ask for: endpoint, method, auth requirements, payload
  ‚îÇ   ‚îú‚îÄ Generate: Feature file with scenarios
  ‚îÇ   ‚îî‚îÄ Include: Response validation, status codes, schema validation
  ‚îú‚îÄ IF E2E test:
  ‚îÇ   ‚îú‚îÄ Use Playwright for multi-step flows
  ‚îÇ   ‚îú‚îÄ Ask for: Complete user journey steps
  ‚îÇ   ‚îú‚îÄ Generate: Modular test with reusable functions
  ‚îÇ   ‚îî‚îÄ Include: @E2E tag, comprehensive logging, checkpoints
  ‚îî‚îÄ ALWAYS:
      ‚îú‚îÄ Add appropriate tags
      ‚îú‚îÄ Include error handling
      ‚îú‚îÄ Follow naming conventions
      ‚îî‚îÄ Add documentation comments
```

### When User Requests Refactoring

```
IF request contains "refactor" OR "improve" OR "optimize":
  ‚îú‚îÄ Analyze existing code for:
  ‚îÇ   ‚îú‚îÄ Code duplication (create utilities)
  ‚îÇ   ‚îú‚îÄ Hardcoded values (move to config/vault)
  ‚îÇ   ‚îú‚îÄ Missing error handling (add try-catch)
  ‚îÇ   ‚îú‚îÄ Poor naming (suggest improvements)
  ‚îÇ   ‚îî‚îÄ Missing documentation (add comments)
  ‚îú‚îÄ Check for anti-patterns:
  ‚îÇ   ‚îú‚îÄ Implicit waits ‚Üí Convert to explicit
  ‚îÇ   ‚îú‚îÄ sleep() calls ‚Üí Replace with proper waits
  ‚îÇ   ‚îú‚îÄ Hardcoded credentials ‚Üí Move to vault
  ‚îÇ   ‚îî‚îÄ Repeated code ‚Üí Extract to utilities
  ‚îú‚îÄ Suggest improvements:
  ‚îÇ   ‚îú‚îÄ Show before/after comparison
  ‚îÇ   ‚îú‚îÄ Explain benefits of changes
  ‚îÇ   ‚îî‚îÄ Highlight any breaking changes
  ‚îî‚îÄ MAINTAIN:
      ‚îú‚îÄ All existing functionality
      ‚îú‚îÄ Test coverage
      ‚îî‚îÄ Backward compatibility (flag if not possible)
```

### When User Reports a Bug/Failure

```
IF request contains "failing" OR "broken" OR "error" OR "bug":
  ‚îú‚îÄ Ask for:
  ‚îÇ   ‚îú‚îÄ Error message/stack trace
  ‚îÇ   ‚îú‚îÄ Test file name
  ‚îÇ   ‚îú‚îÄ Environment (dev, test, prod)
  ‚îÇ   ‚îî‚îÄ Steps to reproduce
  ‚îú‚îÄ Analyze for common issues:
  ‚îÇ   ‚îú‚îÄ Timing issues (add proper waits)
  ‚îÇ   ‚îú‚îÄ Stale elements (refresh locators)
  ‚îÇ   ‚îú‚îÄ Environment differences (check config)
  ‚îÇ   ‚îú‚îÄ Flaky selectors (suggest more robust locators)
  ‚îÇ   ‚îî‚îÄ Data dependencies (check test data setup)
  ‚îú‚îÄ Provide:
  ‚îÇ   ‚îú‚îÄ Root cause analysis
  ‚îÇ   ‚îú‚îÄ Fixed code with explanations
  ‚îÇ   ‚îú‚îÄ Prevention strategies
  ‚îÇ   ‚îî‚îÄ Enhanced error handling
  ‚îî‚îÄ Suggest:
      ‚îú‚îÄ Additional logging points
      ‚îú‚îÄ Retry logic if appropriate
      ‚îî‚îÄ Monitoring/alerting improvements
```

---

## 3. Code Templates by Framework

### Playwright Test Template (TypeScript)

```typescript
import { test, expect, Page } from '@playwright/test';
import { LoginPage } from '../pages/login.page';
import { VaultService } from '../utils/vault.service';
import { Logger } from '../utils/logger';

/**
 * Test Suite: [Feature Name]
 * Description: [What this test suite validates]
 * Owner: [Team/Person]
 */
test.describe('[Feature Name] Tests', () => {
  let loginPage: LoginPage;
  let credentials: { username: string; password: string };
  const logger = new Logger('FeatureName');

  test.beforeEach(async ({ page }) => {
    // Fetch credentials from Vault (NEVER hardcode)
    credentials = await VaultService.getCredentials('test-user');
    loginPage = new LoginPage(page);
    
    logger.info('Test setup completed');
  });

  test.afterEach(async ({ page }, testInfo) => {
    if (testInfo.status !== 'passed') {
      // Capture screenshot on failure
      await page.screenshot({ 
        path: `screenshots/${testInfo.title}-${Date.now()}.png`,
        fullPage: true 
      });
      logger.error(`Test failed: ${testInfo.title}`, testInfo.error);
    }
  });

  /**
   * @Smoke @Functional
   * Test: Validate successful user login
   * Preconditions: User exists in system
   * Expected: User redirected to dashboard
   */
  test('[ACTION_VERB] [WHAT] [EXPECTED_RESULT]', { 
    tag: ['@Smoke', '@Functional'] 
  }, async ({ page }) => {
    try {
      logger.info('Starting login test');
      
      // Navigate to application
      await loginPage.navigate();
      logger.info('Navigated to login page');
      
      // Perform login
      await loginPage.login(credentials.username, credentials.password);
      logger.info('Login credentials submitted');
      
      // Validate successful login
      await expect(page).toHaveURL(/.*dashboard/);
      await expect(page.locator('[data-testid="welcome-message"]')).toBeVisible();
      
      logger.info('Login validation successful');
    } catch (error) {
      logger.error('Login test failed', error);
      throw error;
    }
  });
});
```

### Page Object Model Template (TypeScript)

```typescript
import { Page, Locator } from '@playwright/test';
import { Logger } from '../utils/logger';

/**
 * Page Object: [Page Name]
 * Description: Represents [page description] and its interactions
 */
export class LoginPage {
  readonly page: Page;
  readonly logger: Logger;
  
  // Locators - use data-testid or stable attributes
  readonly usernameInput: Locator;
  readonly passwordInput: Locator;
  readonly loginButton: Locator;
  readonly errorMessage: Locator;

  constructor(page: Page) {
    this.page = page;
    this.logger = new Logger('LoginPage');
    
    // Define locators with robust selectors
    this.usernameInput = page.locator('[data-testid="username-input"]');
    this.passwordInput = page.locator('[data-testid="password-input"]');
    this.loginButton = page.locator('[data-testid="login-button"]');
    this.errorMessage = page.locator('[data-testid="error-message"]');
  }

  /**
   * Navigate to login page
   */
  async navigate(): Promise<void> {
    await this.page.goto('/login');
    await this.page.waitForLoadState('networkidle');
    this.logger.info('Navigated to login page');
  }

  /**
   * Perform login action
   * @param username - User's username
   * @param password - User's password
   */
  async login(username: string, password: string): Promise<void> {
    try {
      await this.usernameInput.fill(username);
      this.logger.info(`Username entered: ${username}`);
      
      await this.passwordInput.fill(password);
      this.logger.info('Password entered');
      
      await this.loginButton.click();
      this.logger.info('Login button clicked');
      
      // Wait for navigation or error
      await Promise.race([
        this.page.waitForURL(/.*dashboard/, { timeout: 10000 }),
        this.errorMessage.waitFor({ state: 'visible', timeout: 10000 })
      ]);
    } catch (error) {
      this.logger.error('Login failed', error);
      throw new Error(`Login action failed: ${error.message}`);
    }
  }

  /**
   * Check if error message is displayed
   * @returns True if error is visible
   */
  async hasError(): Promise<boolean> {
    return await this.errorMessage.isVisible();
  }

  /**
   * Get error message text
   * @returns Error message content
   */
  async getErrorMessage(): Promise<string> {
    const message = await this.errorMessage.textContent();
    this.logger.info(`Error message: ${message}`);
    return message || '';
  }
}
```

### Karate API Test Template

```gherkin
Feature: API Test - [Feature Name]
  Description: [What this API test validates]
  
  Background:
    * url baseUrl
    * def credentials = callonce read('classpath:vault-service.js')
    * header Content-Type = 'application/json'
    * header Authorization = 'Bearer ' + credentials.token

  @Smoke @API
  Scenario: Validate successful API response
    Given path '/api/v1/endpoint'
    And request { "key": "value" }
    When method POST
    Then status 200
    And match response == 
      """
      {
        "status": "success",
        "data": "#object",
        "timestamp": "#string"
      }
      """
    And match response.data contains { id: '#notnull' }

  @Functional @API
  Scenario Outline: Validate multiple scenarios
    Given path '/api/v1/endpoint'
    And request { "param": "<param>" }
    When method GET
    Then status <expectedStatus>
    And match response.result == "<expectedResult>"
    
    Examples:
      | param | expectedStatus | expectedResult |
      | valid | 200            | success        |
      | invalid | 400          | error          |

  @Regression @API
  Scenario: Validate error handling
    Given path '/api/v1/endpoint'
    And request { "invalid": "data" }
    When method POST
    Then status 400
    And match response.error == '#present'
    And match response.error.message == '#string'
    And match response.error.code == '#number'
```

### Utility Functions Template

```typescript
// vault.service.ts
import { Logger } from './logger';

export class VaultService {
  private static logger = new Logger('VaultService');

  /**
   * Fetch credentials from HashiCorp Vault
   * @param credentialPath - Path to credential in Vault
   * @returns Credentials object
   */
  static async getCredentials(credentialPath: string): Promise<any> {
    try {
      // NEVER hardcode credentials
      const vaultUrl = process.env.VAULT_URL;
      const vaultToken = process.env.VAULT_TOKEN;
      
      this.logger.info(`Fetching credentials from Vault: ${credentialPath}`);
      
      // Implement Vault API call
      const response = await fetch(`${vaultUrl}/v1/secret/data/${credentialPath}`, {
        headers: {
          'X-Vault-Token': vaultToken
        }
      });
      
      if (!response.ok) {
        throw new Error(`Vault request failed: ${response.statusText}`);
      }
      
      const data = await response.json();
      this.logger.info('Credentials fetched successfully');
      
      return data.data.data;
    } catch (error) {
      this.logger.error('Failed to fetch credentials from Vault', error);
      throw error;
    }
  }
}

// logger.ts
export class Logger {
  private context: string;

  constructor(context: string) {
    this.context = context;
  }

  info(message: string, data?: any): void {
    console.log(`[${new Date().toISOString()}] [INFO] [${this.context}] ${message}`, data || '');
  }

  error(message: string, error?: any): void {
    console.error(`[${new Date().toISOString()}] [ERROR] [${this.context}] ${message}`, error || '');
  }

  warn(message: string, data?: any): void {
    console.warn(`[${new Date().toISOString()}] [WARN] [${this.context}] ${message}`, data || '');
  }

  debug(message: string, data?: any): void {
    if (process.env.DEBUG === 'true') {
      console.debug(`[${new Date().toISOString()}] [DEBUG] [${this.context}] ${message}`, data || '');
    }
  }
}

// wait.utils.ts
import { Page } from '@playwright/test';

export class WaitUtils {
  /**
   * Wait for element to be visible and stable
   * @param page - Playwright page object
   * @param selector - Element selector
   * @param timeout - Max wait time in ms
   */
  static async waitForElementStable(page: Page, selector: string, timeout = 10000): Promise<void> {
    const element = page.locator(selector);
    await element.waitFor({ state: 'visible', timeout });
    await element.waitFor({ state: 'stable', timeout });
  }

  /**
   * Wait for network to be idle
   * @param page - Playwright page object
   */
  static async waitForNetworkIdle(page: Page): Promise<void> {
    await page.waitForLoadState('networkidle');
  }

  /**
   * Custom wait with retry logic
   * @param condition - Async function that returns boolean
   * @param timeout - Max wait time in ms
   * @param interval - Check interval in ms
   */
  static async waitForCondition(
    condition: () => Promise<boolean>,
    timeout = 10000,
    interval = 500
  ): Promise<void> {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      if (await condition()) {
        return;
      }
      await new Promise(resolve => setTimeout(resolve, interval));
    }
    
    throw new Error(`Condition not met within ${timeout}ms`);
  }
}
```

---

## 4. Naming Conventions (Detailed)

### Test File Naming
```typescript
// ‚úÖ GOOD
login.spec.ts
user-profile-update.spec.ts
withdrawal-process-e2e.spec.ts
loan-calculator-api.feature

// ‚ùå BAD
test1.spec.ts
myTest.spec.ts
LoginTest.spec.ts (wrong case)
```

### Test Names
```typescript
// ‚úÖ GOOD - Action verb + what + expected result
test('validate successful login with valid credentials', ...)
test('verify error message displayed for invalid password', ...)
test('confirm loan amount calculated correctly', ...)

// ‚ùå BAD
test('test 1', ...)
test('login', ...)
test('should work', ...)
```

### Method Names
```typescript
// ‚úÖ GOOD - Verbs describing action
async fillLoginForm(username: string, password: string): Promise<void>
async validateDashboardLoaded(): Promise<boolean>
async fetchUserData(userId: string): Promise<User>

// ‚ùå BAD
async form(u, p) // Not descriptive
async check() // Too vague
async data() // Not a verb
```

### Variable Names
```typescript
// ‚úÖ GOOD - Descriptive, camelCase
const userName: string = 'testuser';
const isLoggedIn: boolean = false;
const accountBalance: number = 1000.50;
const userProfileData: UserProfile = await fetchProfile();

// ‚ùå BAD
const x = 'testuser'; // Not descriptive
const UserName = 'test'; // Wrong case
const data = await fetch(); // Too generic
```

### Class Names
```typescript
// ‚úÖ GOOD - PascalCase, descriptive
export class LoginPage { }
export class UserProfileService { }
export class WithdrawalRequestValidator { }

// ‚ùå BAD
export class login { } // Wrong case
export class page { } // Too generic
export class LP { } // Abbreviation unclear
```

### Constants
```typescript
// ‚úÖ GOOD - UPPER_SNAKE_CASE for true constants
const MAX_RETRY_ATTEMPTS = 3;
const DEFAULT_TIMEOUT_MS = 30000;
const API_BASE_URL = process.env.API_URL;

// Configuration objects - camelCase
const testConfig = {
  browser: 'chromium',
  headless: true,
  timeout: 30000
};

// ‚ùå BAD
const max = 3; // Not clear it's a constant
const TIMEOUT = 30; // Missing units
```

---

## 5. Error Handling Patterns

### Try-Catch Implementation
```typescript
// ‚úÖ COMPREHENSIVE ERROR HANDLING
async performComplexOperation(): Promise<void> {
  try {
    logger.info('Starting complex operation');
    
    // Step 1
    await this.step1();
    logger.info('Step 1 completed');
    
    // Step 2
    await this.step2();
    logger.info('Step 2 completed');
    
    // Step 3
    await this.step3();
    logger.info('Step 3 completed');
    
  } catch (error) {
    // Log error with context
    logger.error('Complex operation failed', {
      errorMessage: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
    
    // Capture screenshot if browser context available
    if (this.page) {
      await this.page.screenshot({ 
        path: `error-screenshots/${Date.now()}.png` 
      });
    }
    
    // Re-throw with more context
    throw new Error(`Complex operation failed at step: ${error.message}`);
  } finally {
    // Cleanup resources
    logger.info('Cleaning up resources');
    await this.cleanup();
  }
}
```

### Assertion with Meaningful Messages
```typescript
// ‚úÖ GOOD - Clear assertion messages
await expect(page.locator('[data-testid="balance"]'))
  .toHaveText('$1,000.50', { 
    timeout: 5000,
    message: 'Account balance should display $1,000.50 after deposit'
  });

await expect(response.status).toBe(200, 
  `Expected successful response, got ${response.status}`
);

// ‚ùå BAD - No context
await expect(page.locator('[data-testid="balance"]')).toHaveText('$1,000.50');
```

### Retry Logic for Flaky Operations
```typescript
/**
 * Retry operation with exponential backoff
 */
async retryOperation<T>(
  operation: () => Promise<T>,
  maxAttempts = 3,
  delayMs = 1000
): Promise<T> {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      logger.info(`Attempt ${attempt}/${maxAttempts}`);
      return await operation();
    } catch (error) {
      if (attempt === maxAttempts) {
        logger.error(`All ${maxAttempts} attempts failed`, error);
        throw error;
      }
      
      const delay = delayMs * Math.pow(2, attempt - 1); // Exponential backoff
      logger.warn(`Attempt ${attempt} failed, retrying in ${delay}ms`, error);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw new Error('Operation failed after all retries');
}

// Usage
const userData = await retryOperation(() => 
  fetchUserDataFromAPI(userId), 
  3, 
  2000
);
```

---

## 6. Test Tagging Strategy

### Tag Application Rules
```typescript
// ‚úÖ CORRECT TAGGING
test('validate login redirects to dashboard', { 
  tag: ['@Smoke', '@Functional', '@E2E'] 
}, async ({ page }) => {
  // Test implementation
});

// Multiple related tags allowed
test('verify 401k withdrawal calculation', { 
  tag: ['@Functional', '@Regression', '@FinancialCalculation'] 
}, async ({ page }) => {
  // Test implementation
});

// ‚ùå INCORRECT - No tags
test('some test', async ({ page }) => {
  // This will fail code review
});
```

### Tag Definitions with Use Cases
```
@Smoke
‚îú‚îÄ Purpose: Critical path validation
‚îú‚îÄ Execution: Before every deployment
‚îú‚îÄ Target Duration: <10 minutes
‚îî‚îÄ Example: Login, navigation, critical transactions

@Functional
‚îú‚îÄ Purpose: Feature acceptance validation
‚îú‚îÄ Execution: Per sprint/feature
‚îú‚îÄ Target Duration: <30 minutes
‚îî‚îÄ Example: New feature validation, edge cases

@Regression
‚îú‚îÄ Purpose: Comprehensive system validation
‚îú‚îÄ Execution: Nightly builds, pre-release
‚îú‚îÄ Target Duration: <2 hours
‚îî‚îÄ Example: All functional scenarios

@E2E
‚îú‚îÄ Purpose: Complete user journey validation
‚îú‚îÄ Execution: Daily, pre-release
‚îú‚îÄ Target Duration: <45 minutes
‚îî‚îÄ Example: User onboarding, loan application process

@Health
‚îú‚îÄ Purpose: System health checks
‚îú‚îÄ Execution: Continuous (synthetic monitoring)
‚îú‚îÄ Target Duration: <5 minutes
‚îî‚îÄ Example: Service availability, database connectivity

@Visual
‚îú‚îÄ Purpose: UI consistency validation
‚îú‚îÄ Execution: Per UI change
‚îú‚îÄ Target Duration: <20 minutes
‚îî‚îÄ Example: Screenshot comparison, responsive design

@Accessibility
‚îú‚îÄ Purpose: ADA/WCAG compliance validation
‚îú‚îÄ Execution: Per UI change
‚îú‚îÄ Target Duration: <15 minutes
‚îî‚îÄ Example: Screen reader compatibility, keyboard navigation

@API
‚îú‚îÄ Purpose: API contract and functionality validation
‚îú‚îÄ Execution: Per API change
‚îú‚îÄ Target Duration: <15 minutes
‚îî‚îÄ Example: Endpoint validation, response schema

@Performance
‚îú‚îÄ Purpose: Load and performance validation
‚îú‚îÄ Execution: Weekly, pre-release
‚îú‚îÄ Target Duration: <1 hour
‚îî‚îÄ Example: Load testing, stress testing, response time validation
```

### Custom Domain Tags
```
@401k - Tests specific to 401k processing
@Loans - Tests specific to loan functionality
@Withdrawals - Tests specific to withdrawal processing
@Hardship - Tests specific to hardship withdrawals
@FocusPoint - Tests specific to FocusPoint application
@Angular - Tests specific to Angular UI components
```

---

## 7. Secrets and PII Management

### CRITICAL SECURITY RULES

```typescript
// ‚ùå NEVER DO THIS - Hardcoded credentials
const username = 'admin@fidelity.com';
const password = 'SuperSecret123!';
const apiKey = 'sk-1234567890abcdef';

// ‚ùå NEVER DO THIS - PII in logs
logger.info(`User SSN: ${userSSN}`);
logger.info(`Account number: ${accountNumber}`);

// ‚úÖ ALWAYS DO THIS - Fetch from Vault
const credentials = await VaultService.getCredentials('qa/test-user');
const apiKey = await VaultService.getSecret('api-keys/internal-service');

// ‚úÖ MASK PII in logs
logger.info(`User SSN: ***-**-${userSSN.slice(-4)}`);
logger.info(`Account: ****${accountNumber.slice(-4)}`);
```

### Vault Integration Pattern
```typescript
export class VaultService {
  private static vaultClient: VaultClient;

  static async initialize(): Promise<void> {
    this.vaultClient = new VaultClient({
      endpoint: process.env.VAULT_URL,
      token: process.env.VAULT_TOKEN
    });
  }

  /**
   * Fetch test user credentials
   * @param userType - Type of test user (admin, standard, readonly)
   */
  static async getTestUser(userType: string): Promise<TestUser> {
    const path = `qa/users/${userType}`;
    const secret = await this.vaultClient.read(path);
    
    return {
      username: secret.data.username,
      password: secret.data.password,
      role: secret.data.role
    };
  }

  /**
   * Fetch API credentials
   * @param serviceName - Name of the service
   */
  static async getAPICredentials(serviceName: string): Promise<APICredentials> {
    const path = `qa/api-keys/${serviceName}`;
    const secret = await this.vaultClient.read(path);
    
    return {
      apiKey: secret.data.apiKey,
      apiSecret: secret.data.apiSecret,
      endpoint: secret.data.endpoint
    };
  }
}

// Usage in tests
test.beforeEach(async () => {
  const testUser = await VaultService.getTestUser('standard');
  const apiCreds = await VaultService.getAPICredentials('retirement-api');
  
  // Use credentials in test
});
```

### PII Masking Utility
```typescript
export class PIIMasker {
  /**
   * Mask Social Security Number
   */
  static maskSSN(ssn: string): string {
    if (!ssn || ssn.length < 4) return '***-**-****';
    return `***-**-${ssn.slice(-4)}`;
  }

  /**
   * Mask account number
   */
  static maskAccount(account: string): string {
    if (!account || account.length < 4) return '********';
    return `****${account.slice(-4)}`;
  }

  /**
   * Mask email address
   */
  static maskEmail(email: string): string {
    const [local, domain] = email.split('@');
    if (!local || !domain) return '***@***.com';
    return `${local.slice(0, 2)}***@${domain}`;
  }

  /**
   * Mask credit card
   */
  static maskCreditCard(card: string): string {
    if (!card || card.length < 4) return '****-****-****-****';
    return `****-****-****-${card.slice(-4)}`;
  }
}

// Usage in logging
logger.info('User logged in', {
  username: testUser.username,
  ssn: PIIMasker.maskSSN(testUser.ssn),
  account: PIIMasker.maskAccount(testUser.accountNumber)
});
```

---

## 8. Code Review Checklist

### Pre-Commit Validation (AI Should Check)

```markdown
## Test Implementation
- [ ] Test has descriptive name with action verb
- [ ] Test has at least one appropriate tag
- [ ] Test follows Page Object Model pattern
- [ ] Test includes error handling (try-catch)
- [ ] Test captures screenshots on failure
- [ ] Test includes comprehensive logging
- [ ] Assertions have descriptive failure messages

## Code Quality
- [ ] No hardcoded credentials or PII
- [ ] All secrets fetched from Vault
- [ ] No implicit waits or sleep() calls
- [ ] No code duplication (extracted to utilities)
- [ ] Follows naming conventions (camelCase, PascalCase, kebab-case)
- [ ] No commented-out code
- [ ] No console.log() statements (use logger)

## Documentation
- [ ] Complex logic has explanatory comments
- [ ] Public methods have JSDoc comments
- [ ] Test suite has description header
- [ ] Test has preconditions and expected results documented

## Error Handling
- [ ] Try-catch blocks around critical operations
- [ ] Errors logged with context
- [ ] Screenshots captured on failure
- [ ] Cleanup in finally blocks
- [ ] Meaningful error messages

## Performance
- [ ] Uses explicit waits appropriately
- [ ] No unnecessary delays
- [ ] Efficient locator strategies
- [ ] Proper cleanup of resources

## Security
- [ ] No credentials in code
- [ ] PII properly masked in logs
- [ ] Vault integration for secrets
- [ ] No sensitive data in screenshots

## Maintainability
- [ ] Code is modular and reusable
- [ ] Page objects properly structured
- [ ] Utilities extracted for common functions
- [ ] Test data externalized
- [ ] Config values in environment variables
```

### AI Code Review Response Template

When reviewing code, AI should respond in this format:

```markdown
## Code Review Summary

### ‚úÖ Strengths
- List what's done well

### ‚ö†Ô∏è Issues Found
1. **[Severity: Critical/High/Medium/Low]** Issue description
   - Current code: `code snippet`
   - Problem: Explanation
   - Fix: `corrected code snippet`
   - Why: Explanation of why this matters

### üîß Suggested Improvements
- Optional enhancements for better code quality

### üìä Checklist Status
[X] Item passed
[ ] Item needs attention

### üéØ Recommendation
**[Approve / Approve with changes / Request changes]**
Summary of recommendation
```

---

## 9. Integration with Observability Tools

### Report Portal Integration
```typescript
import { Reporter } from '@reportportal/agent-js-playwright';

// playwright.config.ts
export default defineConfig({
  reporter: [
    ['@reportportal/agent-js-playwright', {
      apiKey: process.env.REPORT_PORTAL_API_KEY,
      endpoint: process.env.REPORT_PORTAL_ENDPOINT,
      project: 'fidelity-qa-automation',
      launch: 'Regression Suite',
      description: 'Automated test execution',
      attributes: [
        { key: 'environment', value: 'qa' },
        { key: 'team', value: 'quality-engineering' }
      ]
    }]
  ]
});

// Custom logging to Report Portal
test('example with RP logging', async ({ page }) => {
  // Log info
  await test.info().annotations.push({ 
    type: 'info', 
    description: 'Starting user login flow' 
  });
  
  // Log screenshot
  const screenshot = await page.screenshot();
  await test.info().attach('login-page', {
    body: screenshot,
    contentType: 'image/png'
  });
});
```

### Datadog Metrics
```typescript
import { StatsD } from 'node-dogstatsd';

export class DatadogMetrics {
  private static client = new StatsD({
    host: process.env.DATADOG_HOST,
    port: 8125
  });

  /**
   * Track test execution time
   */
  static trackTestDuration(testName: string, duration: number): void {
    this.client.timing('test.execution.duration', duration, {
      test_name: testName,
      environment: process.env.ENV
    });
  }

  /**
   * Track test result
   */
  static trackTestResult(testName: string, passed: boolean): void {
    this.client.increment('test.execution.count', {
      test_name: testName,
      result: passed ? 'passed' : 'failed',
      environment: process.env.ENV
    });
  }

  /**
   * Track flaky test
   */
  static trackFlakyTest(testName: string): void {
    this.client.increment('test.flaky.count', {
      test_name: testName
    });
  }
}

// Usage in test
test.afterEach(async ({}, testInfo) => {
  DatadogMetrics.trackTestDuration(testInfo.title, testInfo.duration);
  DatadogMetrics.trackTestResult(testInfo.title, testInfo.status === 'passed');
});
```

### Grafana Dashboard Metrics
```typescript
// Push custom metrics to Grafana
export class GrafanaMetrics {
  /**
   * Push quality score metrics
   */
  static async pushQualityScore(score: QualityScore): Promise<void> {
    const metrics = [
      {
        name: 'qa.quality_score.total',
        value: score.total,
        timestamp: Date.now()
      },
      {
        name: 'qa.quality_score.pass_rate',
        value: score.passRate,
        timestamp: Date.now()
      },
      {
        name: 'qa.quality_score.coverage',
        value: score.coverage,
        timestamp: Date.now()
      }
    ];

    await fetch(process.env.GRAFANA_PUSH_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(metrics)
    });
  }
}
```

### Jira/Xray Integration
```typescript
/**
 * Automatically create Jira issues for test failures
 */
export class JiraIntegration {
  static async createBugForFailure(testInfo: TestInfo, error: Error): Promise<string> {
    const jiraClient = new JiraClient({
      host: process.env.JIRA_HOST,
      apiKey: await VaultService.getSecret('jira/api-key')
    });

    const issue = await jiraClient.createIssue({
      fields: {
        project: { key: 'QE' },
        summary: `Test Failure: ${testInfo.title}`,
        description: formatFailureDescription(testInfo, error),
        issuetype: { name: 'Bug' },
        priority: { name: 'High' },
        labels: ['automation-failure', 'qa'],
        components: [{ name: 'Automation' }],
        customFields: {
          'Test File': testInfo.file,
          'Environment': process.env.ENV,
          'Test Tags': testInfo.tags.join(', ')
        }
      }
    });

    return issue.key;
  }
}

function formatFailureDescription(testInfo: TestInfo, error: Error): string {
  return `
h3. Test Details
* Test Name: ${testInfo.title}
* Test File: ${testInfo.file}
* Duration: ${testInfo.duration}ms
* Tags: ${testInfo.tags.join(', ')}

h3. Error Details
{code:javascript}
${error.message}
${error.stack}
{code}

h3. Steps to Reproduce
1. Run test: \`${testInfo.title}\`
2. Environment: ${process.env.ENV}

h3. Attachments
See attached screenshots and logs
  `;
}
```

---

## 10. Performance and Compliance

### Performance Requirements
```typescript
// Set performance budgets
test('page should load within performance budget', async ({ page }) => {
  const startTime = Date.now();
  
  await page.goto('/dashboard');
  await page.waitForLoadState('networkidle');
  
  const loadTime = Date.now() - startTime;
  
  // Performance assertion
  expect(loadTime).toBeLessThan(3000); // 3 second budget
  
  // Log performance metric
  logger.info('Page load performance', {
    loadTime,
    budget: 3000,
    status: loadTime < 3000 ? 'pass' : 'fail'
  });
});

// Monitor API response times
test('API should respond within SLA', async ({ request }) => {
  const startTime = Date.now();
  
  const response = await request.get('/api/v1/accounts');
  
  const responseTime = Date.now() - startTime;
  
  expect(response.status()).toBe(200);
  expect(responseTime).toBeLessThan(500); // 500ms SLA
});
```

### Compliance Requirements
```typescript
/**
 * FINTECH COMPLIANCE CHECKLIST
 * 
 * For tests handling financial data:
 * 1. All PII must be masked in logs
 * 2. No financial data in screenshots
 * 3. Audit trail must be maintained
 * 4. Test data must be properly segregated
 * 5. Access must be role-based
 */

// Audit trail logging
export class AuditLogger {
  static logTestAction(action: string, details: any): void {
    const auditEntry = {
      timestamp: new Date().toISOString(),
      action,
      user: process.env.TEST_USER,
      environment: process.env.ENV,
      details: sanitizeForAudit(details)
    };
    
    // Send to audit logging system
    sendToAuditLog(auditEntry);
  }
}

function sanitizeForAudit(data: any): any {
  // Remove or mask sensitive fields
  const sanitized = { ...data };
  
  if (sanitized.ssn) sanitized.ssn = PIIMasker.maskSSN(sanitized.ssn);
  if (sanitized.accountNumber) sanitized.accountNumber = PIIMasker.maskAccount(sanitized.accountNumber);
  if (sanitized.password) delete sanitized.password;
  
  return sanitized;
}
```

---

## 11. AI-Specific Instructions

### When Generating Test Code

```
ALWAYS:
1. Start with Page Object Model pattern
2. Include comprehensive error handling
3. Add appropriate test tags
4. Use Vault for credentials
5. Add meaningful logging
6. Capture screenshots on failure
7. Include JSDoc comments
8. Follow naming conventions strictly
9. Add assertions with descriptive messages
10. Use explicit waits only

NEVER:
1. Hardcode credentials
2. Use implicit waits or sleep()
3. Skip error handling
4. Create tests without tags
5. Leave commented code
6. Use generic variable names
7. Skip documentation
8. Ignore PII masking requirements
9. Create duplicate code
10. Use console.log() (use logger instead)
```

### Code Generation Workflow

```
STEP 1: Clarify Requirements
‚îú‚îÄ Ask about test type (UI/API/E2E)
‚îú‚îÄ Ask about framework (Playwright/Karate/Selenium)
‚îú‚îÄ Ask about scope and user flow
‚îî‚îÄ Confirm expected outcomes

STEP 2: Generate Structure
‚îú‚îÄ Create page object(s) if needed
‚îú‚îÄ Create utility functions if needed
‚îú‚îÄ Set up proper imports
‚îî‚îÄ Define test suite structure

STEP 3: Implement Test Logic
‚îú‚îÄ Add setup (beforeEach)
‚îú‚îÄ Add teardown (afterEach)
‚îú‚îÄ Implement test steps
‚îú‚îÄ Add assertions
‚îî‚îÄ Add error handling

STEP 4: Add Observability
‚îú‚îÄ Add logging statements
‚îú‚îÄ Add screenshot capture
‚îú‚îÄ Add performance tracking
‚îî‚îÄ Add metrics reporting

STEP 5: Review & Validate
‚îú‚îÄ Check against code review checklist
‚îú‚îÄ Verify naming conventions
‚îú‚îÄ Confirm no hardcoded secrets
‚îú‚îÄ Validate error handling
‚îî‚îÄ Ensure proper documentation
```

### Response Format for Test Generation

```markdown
## Generated Test Implementation

### Overview
[Brief description of what the test does]

### Files Created
1. `path/to/test.spec.ts` - Main test file
2. `path/to/page.page.ts` - Page object (if applicable)
3. `path/to/utils.ts` - Utility functions (if applicable)

### Code

[Full code implementation with explanations]

### Usage
```bash
# Run this specific test
npx playwright test path/to/test.spec.ts

# Run with specific tags
npx playwright test --grep @Smoke
```

### Notes
- [Any important notes about the implementation]
- [Dependencies or setup required]
- [Known limitations or future improvements]

### Validation Checklist
- [x] Follows naming conventions
- [x] Includes error handling
- [x] Has appropriate tags
- [x] Uses Page Object Model
- [x] No hardcoded credentials
- [x] Comprehensive logging
- [x] Screenshot capture on failure
```

---

## 12. Common Anti-Patterns to Avoid

### ‚ùå Anti-Pattern: Hardcoded Waits
```typescript
// BAD
await page.waitForTimeout(5000); // Never use fixed timeouts
await new Promise(resolve => setTimeout(resolve, 3000));

// GOOD
await page.waitForSelector('[data-testid="element"]', { state: 'visible' });
await page.waitForLoadState('networkidle');
await expect(page.locator('[data-testid="element"]')).toBeVisible();
```

### ‚ùå Anti-Pattern: Fragile Selectors
```typescript
// BAD - Fragile selectors
await page.click('body > div:nth-child(3) > button');
await page.click('.submit-btn'); // Class name may change

// GOOD - Stable selectors
await page.click('[data-testid="submit-button"]');
await page.click('[aria-label="Submit form"]');
await page.click('button:has-text("Submit")');
```

### ‚ùå Anti-Pattern: No Error Context
```typescript
// BAD
try {
  await page.click('button');
} catch (error) {
  throw error; // No context added
}

// GOOD
try {
  await page.click('[data-testid="submit-button"]');
} catch (error) {
  logger.error('Failed to click submit button', {
    error: error.message,
    selector: '[data-testid="submit-button"]',
    pageUrl: page.url()
  });
  
  await page.screenshot({ path: 'error-submit-button.png' });
  
  throw new Error(`Submit button click failed: ${error.message}`);
}
```

### ‚ùå Anti-Pattern: Test Interdependence
```typescript
// BAD - Tests depend on execution order
test('create user', async () => {
  await createUser();
  globalUserId = userId; // Setting global state
});

test('update user', async () => {
  await updateUser(globalUserId); // Depends on previous test
});

// GOOD - Independent tests
test('create user', async () => {
  const userId = await createUser();
  expect(userId).toBeDefined();
  
  // Cleanup
  await deleteUser(userId);
});

test('update user', async () => {
  // Create fresh user for this test
  const userId = await createUser();
  
  await updateUser(userId);
  expect(await getUser(userId)).toHaveProperty('updated', true);
  
  // Cleanup
  await deleteUser(userId);
});
```

### ‚ùå Anti-Pattern: Unclear Assertions
```typescript
// BAD
expect(result).toBeTruthy();
expect(data.length).toBeGreaterThan(0);

// GOOD
expect(result.success).toBe(true, 'API call should succeed');
expect(data.accounts).toHaveLength(3, 'User should have exactly 3 accounts');
expect(data.balance).toBeCloseTo(1000.50, 2, 'Balance should match expected value');
```

---

## 13. Fintech-Specific Testing Considerations

### Financial Calculations
```typescript
// ALWAYS use precise decimal arithmetic for financial calculations
import Decimal from 'decimal.js';

test('validate 401k withdrawal calculation', async ({ page }) => {
  const principal = new Decimal('100000.00');
  const withdrawalRate = new Decimal('0.04'); // 4%
  
  const expectedWithdrawal = principal.times(withdrawalRate);
  
  await page.fill('[data-testid="principal"]', principal.toString());
  await page.fill('[data-testid="rate"]', withdrawalRate.times(100).toString());
  await page.click('[data-testid="calculate"]');
  
  const displayedAmount = await page.locator('[data-testid="withdrawal-amount"]').textContent();
  const actualAmount = new Decimal(displayedAmount.replace(/[$,]/g, ''));
  
  // Use Decimal comparison for financial assertions
  expect(actualAmount.equals(expectedWithdrawal)).toBe(true, 
    `Expected ${expectedWithdrawal.toString()} but got ${actualAmount.toString()}`
  );
});
```

### Regulatory Compliance Testing
```typescript
/**
 * Test hardship withdrawal eligibility per IRS regulations
 * Reference: IRS Publication 575
 */
test('@Compliance validate hardship withdrawal eligibility', async ({ page }) => {
  const logger = new Logger('HardshipWithdrawalTest');
  
  // Test must verify IRS hardship withdrawal criteria
  const eligibilityCriteria = {
    medicalExpenses: true,
    primaryResidencePurchase: true,
    tuitionPayment: true,
    preventEviction: true,
    funeralExpenses: true,
    repairDamage: true
  };
  
  for (const [reason, shouldBeEligible] of Object.entries(eligibilityCriteria)) {
    logger.info(`Testing hardship reason: ${reason}`);
    
    await page.selectOption('[data-testid="hardship-reason"]', reason);
    await page.click('[data-testid="check-eligibility"]');
    
    const isEligible = await page.locator('[data-testid="eligibility-result"]')
      .textContent() === 'Eligible';
    
    expect(isEligible).toBe(shouldBeEligible, 
      `Hardship reason '${reason}' eligibility check failed`
    );
    
    // Audit log for compliance
    AuditLogger.logTestAction('hardship_eligibility_check', {
      reason,
      result: isEligible,
      regulation: 'IRS Publication 575'
    });
  }
});
```

### Transaction Testing
```typescript
/**
 * Test transaction processing with proper audit trail
 */
test('@E2E @Financial process loan distribution', async ({ page }) => {
  const transactionId = `TXN-${Date.now()}`;
  const logger = new Logger('LoanDistribution');
  
  // Start transaction audit
  AuditLogger.logTestAction('transaction_start', {
    transactionId,
    type: 'loan_distribution'
  });
  
  try {
    // Step 1: Verify account balance
    const initialBalance = await getAccountBalance(page);
    logger.info('Initial balance verified', { balance: initialBalance });
    
    // Step 2: Process loan
    const loanAmount = new Decimal('10000.00');
    await page.fill('[data-testid="loan-amount"]', loanAmount.toString());
    await page.click('[data-testid="submit-loan"]');
    
    // Step 3: Wait for processing
    await page.waitForSelector('[data-testid="transaction-complete"]');
    
    // Step 4: Verify final balance
    const finalBalance = await getAccountBalance(page);
    const expectedBalance = new Decimal(initialBalance).plus(loanAmount);
    
    expect(new Decimal(finalBalance).equals(expectedBalance)).toBe(true,
      'Balance should reflect loan distribution'
    );
    
    // Audit success
    AuditLogger.logTestAction('transaction_complete', {
      transactionId,
      initialBalance,
      finalBalance,
      loanAmount: loanAmount.toString(),
      status: 'success'
    });
    
  } catch (error) {
    // Audit failure
    AuditLogger.logTestAction('transaction_failed', {
      transactionId,
      error: error.message,
      status: 'failed'
    });
    throw error;
  }
});
```

---

## 14. Continuous Improvement

### Test Metrics to Track
- **Pass Rate**: Target >95%
- **Execution Time**: Smoke <10min, Regression <2hrs
- **Flakiness Rate**: Target <2%
- **Code Coverage**: Target >80%
- **Mean Time to Detect (MTTD)**: Track defect detection speed
- **Mean Time to Repair (MTTR)**: Track fix implementation speed

### Regular Review Cycles
- **Weekly**: Review failed tests, update flaky tests
- **Monthly**: Review test coverage, retire obsolete tests
- **Quarterly**: Review framework versions, update dependencies
- **Annually**: Comprehensive framework assessment

---

## Conclusion

This enhanced prompt file provides comprehensive guidance for AI coding assistants to generate high-quality, maintainable, and compliant test automation code for Fidelity's quality engineering initiatives. By following these standards, we ensure consistency, security, and excellence across all automation efforts.

**Remember**: Quality is not just about finding bugs‚Äîit's about building confidence in our systems and protecting our customers' financial futures.

---

## Quick Links
- Vault Documentation: [Internal Link]
- Report Portal Dashboard: [Internal Link]
- Grafana QE Dashboard: [Internal Link]
- Jira QE Board: [Internal Link]
- Testing Standards Wiki: [Internal Link]

---

**Version**: 1.0  
**Last Updated**: November 2025  
**Owner**: Quality Engineering Chapter  
**Contact**: [Your Team Email]
